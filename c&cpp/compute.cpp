#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/sha.h>
#include <openssl/ssl.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <vector>
#include <string>
#include<iostream>
#include <codecvt>
#include <locale>
using namespace std;

unsigned char psswd[] = { 0 }, ssid[] = { 0 }, amac[] = { 0 }, smac[] = { 0 }, anonce[] = { 0 }, snonce[] = { 0 };
unsigned char min_Mac[6] = { 0 }, max_Mac[6] = { 0 }, min_Nonce[32] = { 0 }, max_Nonce[32] = { 0 };
unsigned char pmk[32] = { 0 }, ptk_data[100] = { 0 }, ptk[20] = { 0 }, mic[16] = { 0 };
unsigned char label[] = { "Pairwise key expansion" };
char hex_out[512] = { 0 };//测试
const unsigned char ceshi_ptkdata[1] = { 0x00 };

void mac_nonce_compare_create_data(//比较排序，构建ptk输入数据
	unsigned char* anonce,
	unsigned char* snonce,
	unsigned char* amac,
	unsigned char* smac) {
	if (memcmp(amac, smac, 6)<=0)
	{
		memcpy(ptk_data + 23, amac, 6);
		memcpy(ptk_data + 29, smac, 6);
	}
	else
	{
		memcpy(ptk_data + 29, amac, 6);
		memcpy(ptk_data + 23, smac, 6);
	}
	if (memcmp(anonce, snonce, 32) <= 0)
	{
		memcpy(ptk_data + 35, anonce, 32);
		memcpy(ptk_data + 67, snonce, 32);
	}
	else
	{
		memcpy(max_Nonce, anonce, 32);
		memcpy(ptk_data + 67 + 35, snonce, 32);
	}
	memcpy(ptk_data, label, 23);
	
}

void bin2hex(unsigned char* in, char* out) {
	const char hex[] = "0123456789ABCDEF";
	for (int i = 0; i < 32; i++) {
		out[2 * i] = hex[(in[i] >> 4) & 0x0F];  
		out[2 * i + 1] = hex[in[i] & 0x0F];     
	}
	out[32] = '\0'; 
}



void main_compute
(const char* p_passwd,
	unsigned char* p_ssid,
	int ssid_len,
	unsigned char *ptk_data,
	unsigned char* eapol_data){
	unsigned int* abc = 0;
	PKCS5_PBKDF2_HMAC_SHA1(p_passwd,-1,
		p_ssid, ssid_len,4096,32,pmk);//计算pmk
	bin2hex(pmk, hex_out);//测试
	cout << "pmk:" << hex_out << endl;//测试
	ptk_data[99] = 0x00;//计数器，只要一遍
	HMAC(EVP_sha1(), pmk, 32, ptk_data, 100, ptk, abc);//ptk计算
	bin2hex(ptk, hex_out);//测试
	cout << "ptk:" << hex_out<<endl;//测试
	HMAC(EVP_sha1(), ptk, 16, eapol_data, 123, mic,abc);//计算mic，只取ptk前16字节
	bin2hex(mic, hex_out);//测试
	cout <<"mic:"<< hex_out;//测试
}
void compute() {
	char passwd[] = { "12345678" };//密码输入
	unsigned char ssid[] = { 0x6f,0x6e,0x65,0x70,0x6c,0x75,0x73,0x20,0x32};//ssid名称转ASCII后的16进制字节
	unsigned char amac[] = { 0xb6,0x76,0xd8,0x5e,0x01,0x4b };//ap的mac地址
	unsigned char smac[] = { 0xd4,0xd8,0x53,0xff,0x3e,0x12 };//sta的mac地址
	unsigned char anonce[] =
	{ 0x57,0xe4,0x72,0xc2,0x6e,0x84,0xc2,0xf9
	,0xb3,0x21,0x41,0xe6,0x9b,0x08,0x36,0x0c
	,0x17,0x73,0x3d,0x1d,0xaf,0xf1,0x01,0x44
	,0x76,0x88,0x42,0x82,0x68,0xee,0x6e,0x96 };//ap的随机数，第一步握手
	unsigned char snonce[] =
	{ 0xdc,0xeb,0x5f,0x99,0xc9,0x37,0x4e,0xe0
	,0xbd,0x00,0x75,0xcd,0xd7,0x43,0x3a,0xd5
	,0xb9,0x06,0x5e,0x05,0xf1,0x13,0xe2,0x24
	,0xed,0x52,0x6b,0xb1,0x62,0x05,0x30,0x62 };//sta的随机数，第二步握手
	unsigned char eapol_data[] =
	{ 0x01,0x03,0x00,0x77,0x02,0x01,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x01,0xdc,0xeb,0x5f,0x99,0xc9,0x37,0x4e,0xe0,0xbd,0x00,0x75,0xcd,0xd7,0x43,0x3a,
		0xd5,0xb9,0x06,0x5e,0x05,0xf1,0x13,0xe2,0x24,0xed,0x52,0x6b,0xb1,0x62,0x05,0x30,
		0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x18,0x30,0x16,0x01,0x00,0x00,0x0f,0xac,0x04,0x01,0x00,0x00,0x0f,0xac,
		0x04,0x01,0x00,0x00,0x0f,0xac,0x02,0x3c,0x00,0x00,0x00
	};//在802.1X Authentication栏中的数据，mic字段置零
	mac_nonce_compare_create_data(anonce, snonce, amac, smac);//先比较，拼数据
	const char *p_passwd= passwd;//转固定指针
	unsigned char* p_ssid = ssid;//转固定指针
	int ssid_len = sizeof(ssid);//转ssid长度
	main_compute(p_passwd,p_ssid,ssid_len, ptk_data,eapol_data);//进行主计算
}